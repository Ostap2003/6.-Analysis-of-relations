# Аналіз Відношень

## :busts_in_silhouette: Розподілення розробки функцій:
* _Тетяна Присяжник та Лілія Кушта_ - читання відношення з файлу, запис відношення 
в файл. Пошук симетричного та рефлексивного замикання відношень.
* _Остап Дутка_ - пошук транзитивного замикання відношень з використанням алгоритму Уоршела.
Перевірка чи відношення є транзитивним.
* _Устим Ганик_ - розбиття відношення еквівалентності на класи еквівалентності.
* _Богдан Магомета_ - підрахунок кількості усіх транзитивних відношень на множині з n елементів.

<br></br>
## :bookmark_tabs: Описи функцій:

### Читання відношення з файлу, запис відношення в файл
**read_matrix_file(file)** - зчитує файл та повертає список списків, які репрезентують матрицю, подану у файлі.  
**write_matrix(matrix)** - записує матрицю у csv - файл.  
**write_relation(matrix)** - записує матрицю у текстовий файл.
***
###  Пошук рефлексивного замикання відношення
Для отримання рефлексивного замикання відношення варто скористатись функцією find_reflexive_relation,
яка приймає матрицю, як список списків та повертає матрицю рефлексивного замикання даного відношення.

_Приклад:_
```python
>>> find_reflexive_relation([[1, 1, 1], [0, 0, 0], [1, 0, 0]])
[[1, 1, 1], [0, 1, 0], [1, 0, 1]]
```
<br></br>
##### :question: Що таке рефлексивність?
Бінарне відношення R на множині є **рефлексивним**, якщо для кожного a ∈ X виконується **aRa**.
Матриця рефлексивного відношення характеризується тим, що всі елементи головної діагоналі рівні 1.
***
### Пошук симетричного замикання відношення

Для перетворення матриці у симетричну варто скористатись функцією find_symmetric_relation,
яка приймає матрицю, як список списків та перетворює її у симетричну.

_Приклад:_
```python
>>> find_symmetric_relation([[0, 1, 1], [0, 0, 0], [1, 1, 1]])
[[0, 1, 1], [1, 0, 1], [1, 1, 1]]
```
<br></br>
#### :question: Що таке симетричність?

Бінарне відношення R на множині називається симетричним, якщо для кожної пари елементів 
множини (a,b ) виконання відношення (aRb) спричиняє виконання відношення (bRa ). А матриця
такого відношення буде симетрична щодо головної діагоналі.
***
### Знаходження класів еквівалентності
**Для знаходження класів еквівалентності** у відношенні еквівалентності варто скористатися 
функцією **find_equiv_classes(relations)**. У аргументах вона приймає список кортежів 
пар елементів, та повертає список списків класів еквівалентності.

```python
>>> find_equiv_classes([(0, 0), (0, 1), (1, 0), (1, 1), (2, 2), (2, 3), (3, 2), (3, 3)])
[[0, 1], [2, 3]]
```
<br></br>
##### :question: Що таке класи еквівалентності?
Нехай R – відношення еквівалентності на множині А. Множину всіх елементів, які
еквівалентні до елемента a ∈ A, називають класом еквівалентності (елемента а) за
відношенням R. 
***
### Читання відношень з матриці
Функція **matrix_to_relations(matrix)** приймає матрицю у вигляді списку списків,
та повертає список кортежів пар елементів. _Індексація починається з 0._
```python
>>> matrix_to_relations([[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]]
[(0, 0), (0, 1), (1, 0), (1, 1), (2, 2), (2, 3), (3, 2), (3, 3)]
```
***
###  Пошук транзитивного замикання відношення:

**warshall_alg(rel)** - функція, що приймає матрицю у форматі списку списків і за допомогою 
**алгоритму Уоршела** знаходить транзитивне замикання заданого матрицею відношення. Повертає матрицю 
у вигляді списку списків.
Алгоритм Уоршела використовується для знаходження транзитивного замикання, працює з булевою матрицею.
<br></br>
_Псевдокод алгоритму Уоршела:_
```
rel (<- matrix)
for j to n:
    for i to n:
        if rel[i][j] == 1:
            rel[i] = rel[i] ∨ rel[j]
    next i
next j
```

Ітеруємо по колонках, якщо у колонці є 1, то порівнюємо ряди матриці за
індексом ```i``` та ```j``` за допомогою диз'юнкції.  Порівняння реалізоване 
у функції **compare(lst1, lst2)**, яка приймає два ряди (списки) матриці і 
порівнює їхні елементи між собою, формується новий список після порівняння, 
на який буде замінено ```rel[i]```, тобто рядок, де була знайдена 1.

Приклад роботи **compare(lst1, lst2)**:
```python
>>> compare([0, 0, 1], [0, 1, 1])
[0, 1, 1]
```
<br></br>
**check_transition(rel)** - функція, що приймає матрицю у форматі списку списків і за допомогою функції **warshall_alg(rel)** перевіряє чи задане відношння є транзитивне, тобто чи знайдене за допомогою алгоритму Уоршела транзитивне замикання є таким самим як задане користувачем. Повертає ```True``` або ```False```.

Приклад роботи **check_transition(rel)**:
```python
>>> check_transition([[0, 0], [0, 0]])
True
```
***
### Знаходження кількості транзитивних відношень:
Модуль **transitive_counter.py** призначений для знаходження кількості транзитивних відношень на множині з n елементів.

Щоб знайти кількість транзитивних відношень на множині з n елементів, користувач повинен викликати функцію **count_transitive(n)** з аргументом n (кількість елементів множини).
Приклад роботи **count_transitive(n)**:
```python
>>> count_transitive(2)
13
```

Усього в модулі реалізовані такі функції:
1. count_transitive(n)
2. count_transitive_containing(n, prefix)
3. check_transitive(prefix, n)
4. get_element_by_row_column(matrix, n, num_row, num_col)
<br></br>
   
#### Функція count_transitive_containing(n: int, prefix: List[bool])
Ця функція повертає кількість транзитивних відношень на множині з n елементів, матриці яких містять prefix на початку.
prefix - список булевих значень, з яких матриця починається. Наприклад, матриця
```
      1 1 0
M  =  0 0 1
      1 0 1
```
починається з [1, 1, 0, 0], тому що у першому рядку матриці знаходяться 1, 1, 0, а у другому рядку є ще 0. З prefix'а [] починаються всі матриці.
Викликач цієї функції має гарантувати, що prefix[:-1] (Префікс без останнього елементу, якщо він є) не суперечить транзитивності.

Текстовий опис алгоритму, що реалізований в функції:
```commandline
1. Якщо останній елемент prefix'а суперечить транзитивності, то повернути 0
2. Якщо префікс - це всі елементи матриці, то:
    2.1. Якщо останній елемент prefix'а не суперечить транзитивності, то:
        2.1.1. Повернути 1
    2.2. Інакше:
        2.2.1. Повернути 0.
3. Рекурсивно порахувати кількість транзитивних відношень, на множині з n елементі, що починаються з prefix + [True].
4. Рекурсивно порахувати кількість транзитивних відношень, на множині з n елементі, що починаються з prefix + [False].
5. Повернути суму результатів пунктів 3) та 4).
```

Як бачимо, ця функція викликає саму себе з prefix'ом, що має на одне значення більше, доти, коли prefix буде містити всі елементи матриці (тоді ми можемо визначити, чи матриця є транзитивна і повернути 1, якщо так, інакше 0), або коли prefix стане таким, що суперечить транзитивності матриці, яка з нього починається.
Обчислювальну складність алгоритму визначити складно.
По суті, цей алгоритм перебирає всі матриці, окрім тих, для яких ми знаємо ще на початку їх формування, що вони точно не є транзитивні.
В реалізації цієї функції у 1 та 2.1 пунктах використовується функція **check_transitive(prefix, n)**.

<br></br>
#### Функція check_transitive(prefix: List[bool], n: int)
Ця функція перевіряє, чи prefix, з якого починається n×n матриця, не суперечить її транзитивності. Якщо не суперечить, то функція поверне True, інакше False.
Викликач функції має гарантувати, що prefix без його останнього елемента (prefix[:-1]) не суперечить транзитивності матриці, тобто, check_transitive(prefix[:-1], n) має повертати True.

Текстовий опис алгоритму, що реалізований в цій функції:
```commandline
1. Якщо довжина prefix'а - 0, то повернути True.
2. Нехай М - частково заповнена матриця, в якій відомі хіба перші елементи (елементи з prefix'а). Нехай останній елемент prefix'а розміщений в i-му рядку та j-му стовпцю частково заповненої матриці M.
3. Якщо останній елемент prefix'а - False, то:
    3.1. Якщо диз'юнкція кон'юнкцій елементів і-ого рядка та j-ого стовпця - True:
        3.1.1. Повернути False.
    3.2. Інакше:
        3.2.1. Повернути True.
4. Якщо останній елемент prefix'а - True, то:
    4.1. Для кожного відомого елемента і-ого рядка матриці М, що має значення False:
        4.1.1. Нехай k - номер стовпця цього елемента.
        4.1.2. Якщо M[j, k] дорінює True, то повернути False.
    4.2. Для кожного відомого елемента j-ого стовпця матриці М, що має значення False:
        4.2.1. Нехай k - номер рядка цього елемента.
        4.2.2. Якщо М[k, i] дорівнює True, то повернути False.
5. Повернути True.
```

Алгоритм цієї функції - це насправді частина алгоритму множення булевих матриць.

<br></br>
#### Функція get_element_by_row_column(matrix: List[bool], n: int, num_row: int, num_col: int)
Оскільки в модулі transitive_counter.py матриці репрезентуються у вигляді одновимірних масивів, то потрібна функція, що бере з цього одновимірного масиву елемент, що відповідає заданому стовпцю та рядку. Це й робить функція get_element_by_row_column.

***


## :smiley: Враження від виконання проєкту:
> Кажуть, що пояснюючи комусь матеріал, ви самі глибше опановуєте тему, знаходите
> прогалини у своїх знаннях. Пояснити пайтону дискретну математику досить важко, однак
> виконання цього непростого завдання безперечно зробило мої знання більш ґрунтовними - **Устим Ганик**

> Це завдання допомогло мені ще краще зрозуміти алгоритм Уоршела,
> та заодно нагадати принцип його роботи, тож на іспит я вже готовий принаймні з однієї підтеми) - **Остап Дутка**

> Найбільше мені сподобалось працювати в команді та знаходити власне вирішення проблеми, яка була
> мені запропонована, застосовуючи та поєднуючи свої знання з дискретної математики та програмування - **Богдан Магомета**

> Мені сподобалось працювати над проєктом, адже під час роботи вдосконалювались як мої знання з дискретної
> математики та програмування, так і вміння працювати в команді, що є дуже важливим в сучасному світі - **Лілія Кушта**

> Під час виконання проєкту я мала можливість нагадати собі властивості бінарних відношень,
> що є корисним напередодні екзамену, а також краще освоїти процес роботи в одній командні з одногрупниками - **Тетяна Присяжник**

## :speech_balloon: Зворотний зв'язок викладачам та асистентам:
> Завдання були простими на перший погляд, але при розробці заставили досить так довго
> думати над пошуком найефективнішого розв'язання проблем. Також цінним був досвід
> використання github'у для співпраці у команді - **Устим Ганик**

> Робота в команді це крутий досвід, адже задана проблема легко ділиться на частини,
> вирішується, а потім складається докупи в одну загальну картину - **Остап Дутка**

> Я в захваті від роботи над комп'ютерним проєктом. Завдання, хоч і помірної 
> складності, та дуже цікаві - **Богдан Магомета**

> Я вважаю, що дуже добре, що це завдання було даним на командне опрацювання,
> адже робота в команді, по-перше, дозволяє самому краще зрозуміти певні процеси,
> пояснюючи їхню реалізацію іншим, а по-друге, збільшує почуття відповідальності,
> бажання виконати усе якнайкраще, щоб не підвести команду. - **Лілія Кушта**

> Було дуже цікаво подумати, як реалізувати подані завдання, адже це вперше ми 
> розглядали властивості бінарних відношень та матриць саме в такому ключі. - **Тетяна Присяжник**

