Модуль transitive_counter.py призначений для знаходження кількості транзитивних відношень на множині з n елементів.
Щоб знайти кількість транзитивних відношень на множині з n елементів, користувач повинен викликати функцію count_transitive(n) з аргументом n (кількість елементів множини).

Усього в модулі реалізовані такі функції:
1. count_transitive(n)
2. count_transitive_containing(n, prefix)
3. check_transitive(prefix, n)
4. get_element_by_row_column(matrix, n, num_row, num_col)


***** Функція count_transitive_containing(n: int, prefix: List[bool]) *****
Ця функція повертає кількість транзитивних відношень на множині з n елементів, матриці яких містять prefix на початку.
prefix - список булевих значень, з яких матриця починається. Наприклад, матриця
1 1 0
0 0 1
1 0 1
починається з [1, 1, 0, 0], тому що у першому рядку матриці знаходяться 1, 1, 0, а у другому рядку є ще 0. З prefix'а [] починаються всі матриці.
Викликач цієї функції має гарантувати, що prefix[:-1] (Префікс без останнього елементу, якщо він є) не суперечить транзитивності.

Текстовий опис алгоритму, що реалізований в функції:
1) Якщо останній елемент prefix'а суперечить транзитивності, то повернути 0
2) Якщо префікс - це всі елементи матриці, то:
    2.1) Якщо останній елемент prefix'а не суперечить транзитивності, то повернути 1
    2.2) Інакше повернути 0.
3) Рекурсивно порахувати кількість транзитивних відношень, на множині з n елементі, що починаються з prefix + [True].
4) Рекурсивно порахувати кількість транзитивних відношень, на множині з n елементі, що починаються з prefix + [False].
5) Повернути суму результатів пунктів 3) та 4).

Як бачимо, ця функція викликає саму себе з prefix'ом, що має на одне значення більше, доти, коли prefix буде містити всі елементи матриці (тоді ми можемо визначити, чи матриця є транзитивна і повернути 1, якщо так, інакше 0), або коли prefix стане таким, що суперечить транзитивності матриці, яка з нього починається.
Обчислювальну складність алгоритму визначити складно.
По суті, цей алгоритм перебирає всі матриці, окрім тих, для яких ми знаємо ще на початку їх формування, що вони точно не є транзитивні.
В реалізації цієї функції використовується функція check_transitive(prefix, n).


***** Функція check_transitive(prefix: List[bool], n: int) *****
Ця функція перевіряє, чи prefix, з якого починається матриця не суперечить її транзитивності. Якщо не суперечить, то функція поверне True, інакше False.
Викликач функції має гарантувати, що prefix без його останнього елемента (prefix[:-1]) не суперечить транзитивності матриці, тобто, check_transitive(prefix[:-1], n) має повертати True.

Текстовий опис алгоритму, що реалізований в цій функції:
1) Якщо довжина prefix'а - 0, то повернути True.
2) Нехай М - частково заповнена матриця, в якій відомі хіба перші елементи (елементи з prefix'а). Нехай останній елемент prefix'а розміщений в i-му рядку та j-му стовпцю частково заповненої матриці M.
3) Якщо останній елемент prefix'а - False, то:
    3.1) Якщо диз'юнкція кон'юнкцій елементів і-ого рядка та j-ого стовпця - True:
        3.1.1) Повернути False.
    3.2) Інакше:
        3.2.1) Повернути True.
4) Якщо останній елемент prefix'а - True, то:
    4.1) Для кожного відомого елемента і-ого рядка матриці М, що має значення False:
        4.1.1) Нехай k - номер стовпця цього елемента.
        4.1.2) Якщо M[j, k] дорінює True, то повернути False.
    4.2) Для кожного відомого елемента j-ого стовпця матриці М, що має значення False:
        4.2.1) Нехай k - номер рядка цього елемента.
        4.2.2) Якщо М[k, i] дорівнює True, то повернути False.
5) Повернути True.

Алгоритм цієї функції - це насправді частина алгоритму множення матриць.


***** Функція get_element_by_row_column(matrix: List[bool], n: int, num_row: int, num_col: int) *****
Оскільки в модулі transitive_counter.py матриці репрезентуються у вигляді одновимірних масивів, то потрібна функція, що бере з цього одновимірного масиву елемент, що відповідає заданому стовпцю та рядку. Це й робить функція get_element_by_row_column.

